import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import java.lang.reflect.Field;
import java.util.List;
import spl.lae.LinearAlgebraEngine;
import memory.SharedMatrix;
import memory.SharedVector;
import memory.VectorOrientation;

public class TestLAE {
    
    static VectorOrientation horizontal = VectorOrientation.ROW_MAJOR;
    static VectorOrientation vertical = VectorOrientation.COLUMN_MAJOR;

    @Nested
    @DisplayName("Testing task creation")
    class testCreateTasks {
        
        private LinearAlgebraEngine lae;
        private MockSharedMatrix mockLeft;
        private MockSharedMatrix mockRight;
        private MockSharedVector mockVector;

        @BeforeEach
        void setup() throws Exception {
            lae = new LinearAlgebraEngine(4);
            
            // Using mockups, as suggested on "Test-Driven Development" guide on Moodle
            //Creating "fake" matrices and vectors for testing
            mockVector = new MockSharedVector();
            mockLeft = new MockSharedMatrix(3, mockVector, horizontal); 
            mockRight = new MockSharedMatrix(3, mockVector, horizontal);

            // Injecting mocks into LAE instance using reflection 
            injectPrivateField(lae, "leftMatrix", mockLeft);
            injectPrivateField(lae, "rightMatrix", mockRight);
        }

        @Test
        @DisplayName("Test if createAddTasks produces the correct number of tasks")
        public void testCreateAddTasksCount() {
            //The actual method we test
            List<Runnable> tasks = lae.createAddTasks();
            
            // for a 3-row matrix, we expect 3 tasks
            assertEquals(3, tasks.size(), "Should create exactly one task per row.");
        }

        @Test
        @DisplayName("Test if the created task actually calls the add method")
        public void testAddTasksLogic() {
            List<Runnable> tasks = lae.createAddTasks();
            
            // Check that the task is an add operation by running it
            tasks.get(0).run();
            
            // Valdidating that the add method was called on the mock vector
            assertTrue(mockVector.wasAddCalled, "The task should have called the vector's add() method.");
        }

        // Helper function to inject private fields using reflection
        //(Allowed in forum discussion)
        private void injectPrivateField(Object target, String fieldName, Object value) throws Exception {
            Field field = target.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(target, value);
        }
    }

    // Mockup classes implemented as nested classes to avoid creating new files
    private static class MockSharedMatrix extends SharedMatrix {
        private int rowCount;
        private VectorOrientation orientation;
        private SharedVector vector;

        public MockSharedMatrix(int rowCount, VectorOrientation orientation, SharedVector vector) {
            this.rowCount = rowCount;
            this.orientation = orientation;
            this.vector = vector;
        }

        @Override
        public int length() { return rowCount; }

        @Override
        public SharedVector get(int index) { return vector; }

        @Override
        public VectorOrientation getOrientation() { return orientation; }
    }

    private static class MockSharedVector extends SharedVector {
        public boolean wasAddCalled = false;
        public boolean wasVecMatMulCalled = false;
        private int vectorLength;

        public MockSharedVector(int length) {
            this.vectorLength = length;
        }

        @Override
        public void add(SharedVector other) { this.wasAddCalled = true; }

        @Override
        public void vecMatMul(SharedMatrix matrix) { this.wasVecMatMulCalled = true; }

        @Override
        public int length() { return vectorLength; }
    }
}